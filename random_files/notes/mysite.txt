INSTALLATION:
        
    1. pip install Django==2.2.6
        or
        pip3 install Django
    2. django-admin --version
    3. django-admin startproject <sample_folder_name>
    4. cd <sample_folder_name>
    5. python manage.py runserver
    Then, open the link for development server
    6. python manage.py migrate,
        or
        
        python manage.py sqlmigrate polls 0001
            (sample output:
                BEGIN;
                --
                -- Create model Post
                --
                CREATE TABLE "blog_post" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(100) NOT NULL, "date_posted" datetime NOT NULL, "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
                CREATE INDEX "blog_post_author_id_dd7a8485" ON "blog_post" ("author_id");
                COMMIT;
            )
        then,
        python manage.py migrate,

    7. python manage.py createsuperuser
    8. python manage.py runserver
    9. go to http://127.0.0.1:8000/admin #http://127.0.0.1:8000/admin/login/?next=/admin/


Django
    - comes with a utility that automatically generates the basic directory structure of an app, so you can focus on writing code rather than creating directories.

POLL APPLICATION
    2 PARTS:
        A public site that lets people view polls and vote in them.
        An admin site that lets you add, change, and delete polls.

ğŸ”µ Writing your first Django app, part 1

    ğŸ”¸Check Django Version:
        ğŸ”¶ python -m django --version
        ğŸ”¶ django-admin     # check django-admin subcommands

    ğŸ”¸Creating a project

        Django project
            - a collection of settings for an instance of Django, including database configuration, Django-specific options and application-specific settings.

        ğŸ”¶ cd <sampleDirectoryName>
        ğŸ”¶ django-admin startproject mysite


            mysite/
                manage.py
                mysite/
                    __init__.py
                    settings.py
                    urls.py
                    asgi.py
                    wsgi.py 

            FILES:
                The outer mysite/ root directory is a container for your project. Its name doesnâ€™t matter to Django; you can rename it to anything you like.
                
                â—½ manage.py:
                    - A command-line utility that lets you interact with this Django project in various ways.
                    - a shortcut to use the django-admin command-line utility.
                    - used to run management commands related to our project.
                    - use to run the development server, run tests, create migrations and much more.
                
                The inner mysite/ directory is the actual Python package for your project. Its name is the Python package name youâ€™ll need to use to import anything inside it (e.g. mysite.urls).
                
                â—½ mysite/__init__.py:
                    - An empty file that tells Python that this directory should be considered a Python package.
                â—½ mysite/settings.py:
                    - Settings/configuration for this Django project. Django settings will tell you all about how settings work.
                    - this file contains all the projectâ€™s configuration. We will refer to this file all the time!
                â—½ mysite/urls.py:
                    - The URL declarations for this Django project; a â€œtable of contentsâ€ of your Django-powered site.
                    - used to map URLs to certain locations so can be handled in a certain way
                    - ex:
                        if you want to show something in the URL /about/, you have to map it here first.
                â—½ mysite/asgi.py:
                    - An entry-point for ASGI-compatible web servers to serve your project.
                â—½ mysite/wsgi.py:
                    - An entry-point for WSGI-compatible web servers to serve your project.
                    - Used to deploy files
                    - a simple gateway interface used for deployment. You donâ€™t have to bother about it. Just let it be for now.

    ğŸ”¸The development server
        - a lightweight Web server written purely in Python

        ğŸ”¶ python manage.py runserver

            terminal output should be:
                Watching for file changes with StatReloader
                Performing system checks...

                System check identified no issues (0 silenced).

                You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
                Run 'python manage.py migrate' to apply them.

                December 20, 2019 - 06:37:48
                Django version 3.0.1, using settings 'mysite.settings'
                Starting development server at http://127.0.0.1:8080/
                Quit the server with CONTROL-C.
                [20/Dec/2019 06:37:51] "GET / HTTP/1.1" 200 16351
                [20/Dec/2019 06:37:51] "GET /static/admin/css/fonts.css HTTP/1.1" 200 423
                [20/Dec/2019 06:37:51] "GET /static/admin/fonts/Roboto-Regular-webfont.woff HTTP/1.1" 200 85876
                ...
                ...


        Changing the port

            - By default, the runserver command starts the development server on the internal IP at port 8000.
            If you want to change the serverâ€™s port, pass it as a command-line argument. For instance, this command starts the server on port 8080:

                ğŸ’  python manage.py runserver 8080
            
            - If you want to change the serverâ€™s IP, pass it along with the port. For example, to listen on all available public IPs (which is useful if you are running Vagrant or want to show off your work on other computers on the network), use:
            
                ğŸ’  python manage.py runserver 0:8000
                
            - 0 is a shortcut for 0.0.0.0. Full docs for the development server can be found in the runserver reference.


        - DON'T use this server in anything resembling a production environment. Itâ€™s intended only for use while developing. (Weâ€™re in the business of making Web frameworks, not Web servers.)
            
            Automatic reloading of runserver

                - The development server automatically reloads Python code for each request as needed. You donâ€™t need to restart the server for code changes to take effect. However, some actions like adding files donâ€™t trigger a restart, so youâ€™ll have to restart the server in these cases.

    ğŸ”¸Creating the Polls app
            
        Projects vs. apps
            ğŸ”¸app
                - a Web application that does something â€“ e.g., a Weblog system, a database of public records or a small poll app.
                - can be in multiple projects.
            ğŸ”¸project
                - a collection of configuration and apps for a particular website.
                - can contain multiple apps.

        weâ€™ll create our poll app right next to your manage.py file so that it can be imported as its own top-level module, rather than a submodule of mysite.
        To create your app, make sure youâ€™re in the same directory as manage.py and type this command:

            ğŸ”¶ python manage.py startapp polls

                That will create a directory 'polls':
                    
                    polls/
                        __init__.py
                        admin.py
                        apps.py
                        migrations/
                            __init__.py
                        models.py
                        tests.py
                        views.py

                FILES:
                    â—½ migrations/: here Django store some files to keep track of the changes you create in the models.py file, so to keep the database and the models.py synchronized.
                    â—½ admin.py: this is a configuration file for a built-in Django app called Django Admin.
                    â—½ apps.py: this is a configuration file of the app itself.
                    â—½ models.py: here is where we define the entities of our Web application. The models are translated automatically by Django into database tables.
                    â—½ tests.py: this file is used to write unit tests for the app.
                    â—½ views.py: this is the file where we handle the request/response cycle of our Web application.
        
    ğŸ”¸Write your first view
        
        1. Letâ€™s write the first view.Letâ€™s write the first view. Open the file polls/views.py and put the following Python code in it:
            
            ğŸ”¶ polls/views.py
                from django.http import HttpResponse

                def index(request):
                    return HttpResponse("Hello, world. You're at the polls index.")

        
        2. To create a URLconf in the polls directory, create a file called urls.py. Your app directory should now look like:
            
            polls/
                __init__.py
                admin.py
                apps.py
                migrations/
                    __init__.py
                models.py
                tests.py
                urls.py
                views.py


            ğŸ”¶ polls/urls.py
                from django.urls import path

                from . import views

                urlpatterns = [path("", views.index, name="index")]

        3. The next step is to point the root URLconf at the polls.urls module. In mysite/urls.py, add an import for django.urls.include and insert an include() in the urlpatterns list, so you have:

            ğŸ”¶ mysite/urls.py
                from django.contrib import admin
                from django.urls import include, path

                urlpatterns = [
                    path('polls/', include('polls.urls')),
                    path('admin/', admin.site.urls),
                ]


        The include() function allows referencing other URLconfs. Whenever Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing.

        The idea behind include() is to make it easy to plug-and-play URLs. Since polls are in their own URLconf (polls/urls.py), they can be placed under â€œ/polls/â€, or under â€œ/fun_polls/â€, or under â€œ/content/polls/â€, or any other path root, and the app will still work.

            When to use include()

                - should always use include() when you include other URL patterns. 
                - 'admin.site.urls' is the only exception to this.


        4. You have now wired an index view into the URLconf. Verify itâ€™s working with the following command:
            
            To save changes to db:
                ğŸ”¶ python manage.py makemigrations  # check changes
                ğŸ”¶ python manage.py migrate

            ğŸ”¶ python manage.py runserver

        5. Go to http://localhost:8000/polls/ in your browser, and you should see the text â€œHello, world. Youâ€™re at the polls index.â€, which you defined in the index view.


        The path() function is passed four arguments, two required: route and view, and two optional: kwargs, and name. At this point, itâ€™s worth reviewing what these arguments are for.
            
            path() argument: route
                route is a string that contains a URL pattern. When processing a request, Django starts at the first pattern in urlpatterns and makes its way down the list, comparing the requested URL against each pattern until it finds one that matches.

                Patterns donâ€™t search GET and POST parameters, or the domain name. For example, in a request to https://www.example.com/myapp/, the URLconf will look for myapp/. In a request to https://www.example.com/myapp/?page=3, the URLconf will also look for myapp/.

            path() argument: view
                When Django finds a matching pattern, it calls the specified view function with an HttpRequest object as the first argument and any â€œcapturedâ€ values from the route as keyword arguments. Weâ€™ll give an example of this in a bit.

            path() argument: kwargs
                Arbitrary keyword arguments can be passed in a dictionary to the target view. We arenâ€™t going to use this feature of Django in the tutorial.

            path() argument: name
                Naming your URL lets you refer to it unambiguously from elsewhere in Django, especially from within templates. This powerful feature allows you to make global changes to the URL patterns of your project while only touching a single file.

                When youâ€™re comfortable with the basic request and response flow, read part 2 of this tutorial to start working with the database.


ğŸ”µ Writing your first Django app, part 2

    ğŸ”¸Database setup

        1. Open up mysite/settings.py. Itâ€™s a normal Python module with module-level variables representing Django settings.
        
        DEFAULT (configuration uses SQLite)

        If you wish to use another database, install the appropriate database bindings and change the following keys in the DATABASES 'default' item to match your database connection settings:

            ENGINE â€“ Either 'django.db.backends.sqlite3', 'django.db.backends.postgresql', 'django.db.backends.mysql', or 'django.db.backends.oracle'. Other backends are also available.
            
            NAME â€“ The name of your database. If youâ€™re using SQLite, the database will be a file on your computer; in that case, NAME should be the full absolute path, including filename, of that file. The default value, os.path.join(BASE_DIR, 'db.sqlite3'), will store the file in your project directory.

            For databases other than SQLite
                If youâ€™re using a database besides SQLite, make sure youâ€™ve created a database by this point. Do that with â€œCREATE DATABASE database_name;â€ within your databaseâ€™s interactive prompt.

                Also make sure that the database user provided in mysite/settings.py has â€œcreate databaseâ€ privileges. This allows automatic creation of a test database which will be needed in a later tutorial.

                If youâ€™re using SQLite, you donâ€™t need to create anything beforehand - the database file will be created automatically when it is needed.

        EDIT:
            ğŸ”¶ mysite/settings.py
                - set TIME_ZONE to your time zone.
                    # TIME_ZONE = "UTC"
                    ğŸ”¸ TIME_ZONE = "Asia/Manila"
            INSTALLED_APPS 
                - setting at the top of the file.
                - holds the names of all Django applications that are activated in this Django instance. Apps can be used in multiple projects, and you can package and distribute them for use by others in their projects.

            By default, INSTALLED_APPS contains the following apps, all of which come with Django:
                django.contrib.admin â€“ The admin site. Youâ€™ll use it shortly.
                django.contrib.auth â€“ An authentication system.
                django.contrib.contenttypes â€“ A framework for content types.
                django.contrib.sessions â€“ A session framework.
                django.contrib.messages â€“ A messaging framework.
                django.contrib.staticfiles â€“ A framework for managing static files.
                    â€“ collects static files from each of your applications (and any other places you specify) into a single location that can easily be served in production.

                - included by default as a convenience for the common case.
                - application names and labels must be UNIQUE


            Some of these applications make use of at least one database table, though, so we need to create the tables in the database before we can use them. To do that, run the following command:


            ğŸ”¶ python manage.py migrate

                migrate
                    - (command) looks at the INSTALLED_APPS setting and creates any necessary database tables according to the database settings in your mysite/settings.py file and the database migrations shipped with the app

    ğŸ”¸Creating models
        - 2 models: 
            Question
            Choice - each is associated with Question
        
        EDIT:
            ğŸ”¶ polls/models.py
                
                from django.db import models


                class Question(models.Model):
                    question_text = models.CharField(max_length=200)
                    pub_date = models.DateTimeField('date published')


                class Choice(models.Model):
                    question = models.ForeignKey(Question, on_delete=models.CASCADE)
                    choice_text = models.CharField(max_length=200)
                    votes = models.IntegerField(default=0)
        
            Model
                - each is represented by a class that subclasses django.db.models.Model.
                - each has a number of class variables, each of which represents a database field in the model.
            Field
                - represented by an instance of a Field class â€“ e.g., CharField for character fields and DateTimeField for datetimes. (data type)
            
                CharField
                    - requires 'max_length'

                - can have various optional arguments; in this case, weâ€™ve set the default value of votes to 0.

    ğŸ”¸Activating models
         
        That small bit of model code gives Django a lot of information. With it, Django is able to:=
            * Create a database schema (CREATE TABLE statements) for this app.
            * .Create a Python database-access API for accessing Question and Choice objects.

        But first we need to tell our project that the polls app is installed.
            
        Django apps are â€œpluggableâ€: You can use an app in multiple projects, and you can distribute apps, because they donâ€™t have to be tied to a given Django installation.


        EDIT:
            ğŸ”¶ mysite/settings.py

                INSTALLED_APPS = [
                    'polls.apps.PollsConfig',
                    'django.contrib.admin',
                    'django.contrib.auth',
                    'django.contrib.contenttypes',
                    'django.contrib.sessions',
                    'django.contrib.messages',
                    'django.contrib.staticfiles',
                ]

            
            ğŸ”¶ python manage.py makemigrations polls

                SAMPLE OUTPUT:

                    Migrations for 'polls':
                        polls/migrations/0001_initial.py:
                            - Create model Choice
                            - Create model Question
                            - Add field question to choice

        By running makemigrations, youâ€™re telling Django that youâ€™ve made some changes to your models (in this case, youâ€™ve made new ones) and that youâ€™d like the changes to be stored as a migration.

        Migrations are how Django stores changes to your models (and thus your database schema) - theyâ€™re files on disk. You can read the migration for your new model if you like; itâ€™s the file polls/migrations/0001_initial.py. Donâ€™t worry, youâ€™re not expected to read them every time Django makes one, but theyâ€™re designed to be human-editable in case you want to manually tweak how Django changes things.

        Thereâ€™s a command that will run the migrations for you and manage your database schema automatically - thatâ€™s called migrate, and weâ€™ll come to it in a moment - but first, letâ€™s see what SQL that migration would run. The sqlmigrate command takes migration names and returns their SQL:

            ğŸ”¶ python manage.py sqlmigrate polls 0001

                SAMPLE OUTPUT:

                    BEGIN;
                    --
                    -- Create model Question
                    --
                    CREATE TABLE "polls_question" (
                        "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
                        "question_text" varchar(200) NOT NULL,
                        "pub_date" datetime NOT NULL
                    );
                    --
                    -- Create model Choice
                    --
                    CREATE TABLE "polls_choice" (
                        "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
                        "choice_text" varchar(200) NOT NULL,
                        "votes" integer NOT NULL,
                        "question_id" integer NOT NULL REFERENCES "polls_question" ("id") DEFERRABLE INITIALLY DEFERRED);
                    CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");
                    COMMIT;

                    NOTES:
                        ğŸ”¸ Table names are automatically generated by combining the name of the app (polls) and the lowercase name of the model â€“ question and choice. (You can override this behavior.)
                        ğŸ”¸ Primary keys (IDs) are added automatically. (You can override this, too.)
                        ğŸ”¸ By convention, Django appends "_id" to the foreign key field name. (Yes, you can override this, as well.)
                        ğŸ”¸ The foreign key relationship is made explicit by a FOREIGN KEY constraint. Donâ€™t worry about the DEFERRABLE parts; itâ€™s telling PostgreSQL to not enforce the foreign key until the end of the transaction.
                        ğŸ”¸ Itâ€™s tailored to the database youâ€™re using, so database-specific field types such as auto_increment (MySQL), serial (PostgreSQL), or integer primary key autoincrement (SQLite) are handled for you automatically. Same goes for the quoting of field names â€“ e.g., using double quotes or single quotes.
                        ğŸ”¸ sqlmigrate (command)
                            - doesnâ€™t actually run the migration on your database - instead, it prints it to the screen so that you can see what SQL Django thinks is required. Itâ€™s useful for checking what Django is going to do or if you have database administrators who require SQL scripts for changes.
                        
                        ğŸ’  python manage.py check
                            - checks for any problems in your project without making migrations or touching the database.
                            - sampe output:
                                System check identified no issues (0 silenced).
            
            
            ğŸ”¶ python manage.py migrate

                SAMPLE OUTPUT:

                    Operations to perform:
                        Apply all migrations: admin, auth, contenttypes, polls, sessions
                    Running migrations:
                        Applying polls.0001_initial... OK

                    NOTES:
                        ğŸ”¸ migrate (command)
                            - takes all the migrations that havenâ€™t been applied (Django tracks which ones are applied using a special table in your database called django_migrations) and runs them against your database - essentially, synchronizing the changes you made to your models with the schema in the database.

                        MAKING MODEL CHANGES:
                            Change your models (in ğŸ”¸models.py).
                            Run ğŸ”¸python manage.py makemigrationsğŸ”¸ to create migrations for those changes
                            Run ğŸ”¸python manage.py migrateğŸ”¸ to apply those changes to the database.

    ğŸ”¸Playing with the API

        ğŸ”¶ python manage.py shell

            >>> from polls.models import Choice, Question  # Import the model classes we just wrote.
            
            # No questions are in the system yet.
            >>> Question.objects.all()
            <QuerySet []>

            # Create a new Question.
            # Support for time zones is enabled in the default settings file, so
            # Django expects a datetime with tzinfo for pub_date. Use timezone.now()
            # instead of datetime.datetime.now() and it will do the right thing.
            >>> from django.utils import timezone
            >>> q = Question(question_text="What's new?", pub_date=timezone.now())

            # Save the object into the database. You have to call save() explicitly.
            >>> q.save()

            # Now it has an ID
            >>> q.id
            1

            # Access model field values via Python attributes.
            >>> q.question_text
            "What's new?"
            >>> q.pub_date
            datetime.datetime(2019, 12, 23, 2, 5, 14, 124774, tzinfo=<UTC>)
            >>> q.question_text = "What's up? "
            >>> q.save()
            >>> Question.objects.all()
            <QuerySet [<Question: Question object (1)>]>
        

        Wait a minute. <Question: Question object (1)> isnâ€™t a helpful representation of this object. Letâ€™s fix that by editing the Question model (in the polls/models.py file) and adding a __str__() method to both Question and Choice:

        UPDATE:
            ğŸ”¶ polls/models.py
                from django.db import models

                class Question(models.Model):
                    # ...
                    def __str__(self):
                        return self.question_text

                class Choice(models.Model):
                    # ...
                    def __str__(self):
                        return self.choice_text

        Itâ€™s important to add __str__() methods to your models, not only for your own convenience when dealing with the interactive prompt, but also because objectsâ€™ representations are used throughout Djangoâ€™s automatically-generated admin.

        UPDATE:
            ğŸ”¶ polls/models.py
                import datetime

                from django.db import models
                from django.utils import timezone


                class Question(models.Model):
                    # ...
                    def was_published_recently(self):
                        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)



        ğŸ”¶ python manage.py shell
            
            >>> from polls.models import Choice, Question

            # Make sure our __str__() addition worked.
            >>> Question.objects.all()
            <QuerySet [<Question: What's up? >]>

            # Django provides a rich database lookup API that's
            # entirely driven by keyword arguments.
            >>> Question.objects.filter(id=1)
            <QuerySet [<Question: What's up? >]>
            >>> Question.objects.filter(question_text__startswith='What')
            <QuerySet [<Question: What's up? >]>
            
            # Get the question that was published this year.
            >>> from django.utils import timezone
            >>> current_year = timezone.now().year
            >>> Question.objects.get(pub_date__year=current_year)
            <Question: What's up? >
            
            # Request an ID that doesn't exist, this will raise an exception.
            >>> Question.objects.get(id=2)
            Traceback (most recent call last):
            ...
            ...
                self.model._meta.object_name
            polls.models.Question.DoesNotExist: Question matching query does not exist.
            
            # Lookup by a primary key is the most common case, so Django provides a
            # shortcut for primary-key exact lookups.
            # The following is identical to Question.objects.get(id=1).
            >>> Question.objects.get(pk=1)
            <Question: What's up? >
            
            
            # Make sure our custom method worked.
            >>> q = Question.objects.get(pk=1)
            >>> q.was_published_recently()
            True
            

            # Give the Question a couple of Choices. The create call constructs a new
            # Choice object, does the INSERT statement, adds the choice to the set
            # of available choices and returns the new Choice object. Django creates
            # a set to hold the "other side" of a ForeignKey relation
            # (e.g. a question's choice) which can be accessed via the API
            >>> q = Question.objects.get(pk=1)
            
            
            # Display any choices from the related object set -- none so far.
            >>> q.choice_set.all()
            <QuerySet []>
            
            # Create three choices.
            >>> q.choice_set.create(choice_text='Not much', votes=0)
            <Choice: Not much>
            >>> q.choice_set.create(choice_text='The sky', votes=0)
            <Choice: The sky>
            >>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)
            
            
            # Choice objects have API access to their related Question objects.
            >>> c.question
            <Question: What's up? >
            
            
            # And vice versa: Question objects get access to Choice objects.
            >>> q.choice_set.all()
            <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
            >>> q.choice_set.count()
            3
            
            
            
            # The API automatically follows relationships as far as you need.
            # Use double underscores to separate relationships.
            # This works as many levels deep as you want; there's no limit.
            # Find all Choices for any question whose pub_date is in this year
            # (reusing the 'current_year' variable we created above).
            >>> Choice.objects.filter(question__pub_date__year=current_year)
            <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
            
            
            # Let's delete one of the choices. Use delete() for that.
            >>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
            >>> c.delete()
            (1, {'polls.Choice': 1})

    ğŸ”¸Introducing the Django Admin
        
        1. Creating an admin user
            ğŸ”¶ python manage.py createsuperuser

                Username (leave blank to use 'webdev'): admin
                Email address: emelyn.soria@boom.camp
                Password: emzzzzzz
                Password (again): emzzzzzz
                Superuser created successfully.

        2. Start the development server
            ğŸ”¶ python manage.py runserver

                go to: http://127.0.0.1:8000/admin/
            
        3. Enter the admin site
            You should see a few types of editable content: groups and users. They are provided by django.contrib.auth, the authentication framework shipped by Django.

        4. Make the poll app modifiable in the admin
            EDIT:
                ğŸ”¶ polls/admin.py
                    from django.contrib import admin

                    from .models import Question

                    admin.site.register(Question)

        5. Explore the free admin functionality
            Now that weâ€™ve registered Question, Django knows that it should be displayed on the admin index page:

                SAMPLE OUTPUT: ../files/django_admin_output.png

                NOTES:
                    ğŸ”¸The form is automatically generated from the Question model.
                    ğŸ”¸The different model field types (DateTimeField, CharField) correspond to the appropriate HTML input widget. Each type of field knows how to display itself in the Django admin.
                    ğŸ”¸Each DateTimeField gets free JavaScript shortcuts. Dates get a â€œTodayâ€ shortcut and calendar popup, and times get a â€œNowâ€ shortcut and a convenient popup that lists commonly entered times.
                    
                    The bottom part of the page gives you a couple of options:
                        ğŸ”¸Save â€“ Saves changes and returns to the change-list page for this type of object.
                        ğŸ”¸Save and continue editing â€“ Saves changes and reloads the admin page for this object.
                        ğŸ”¸Save and add another â€“ Saves changes and loads a new, blank form for this type of object.
                        ğŸ”¸Delete â€“ Displays a delete confirmation page.


ğŸ”µ Writing your first Django app, part 3

    ğŸ”¸Overview

        Blog homepage â€“ displays the latest few entries.
        Entry â€œdetailâ€ page â€“ permalink page for a single entry.
        Year-based archive page â€“ displays all months with entries in the given year.
        Month-based archive page â€“ displays all days with entries in the given month.
        Day-based archive page â€“ displays all entries in the given day.
        Comment action â€“ handles posting comments to a given entry.
        
        4 views in poll application:
            ğŸ”¸Question â€œindexâ€ page â€“ displays the latest few questions.
            ğŸ”¸Question â€œdetailâ€ page â€“ displays a question text, with no results but with a form to vote.
            ğŸ”¸Question â€œresultsâ€ page â€“ displays results for a particular question.
            ğŸ”¸Vote action â€“ handles voting for a particular choice in a particular question.

        VIEW
            - a â€œtypeâ€ of Web page in your Django application that generally serves a specific function and has a specific template
            - In Django, web pages and other content are delivered by this
            - each is represented by a Python function (or method, in the case of class-based views). Django will choose a view by examining the URL thatâ€™s requested (to be precise, the part of the URL after the domain name).
            - each is responsible for doing one of two things:
                * returning an HttpResponse object containing the content for the requested page,
                * or raising an exception such as Http404. The rest is up to you.
            - can read records from a database, or not.
            - can use a template system such as Djangoâ€™s â€“ or a third-party Python template system â€“ or not. 
            - can generate a PDF file, output XML, create a ZIP file on the fly, anything you want, using whatever Python libraries you want.
            

    ğŸ”¸Writing more views

        ğŸ”¶ polls/views.py
            def detail(request, question_id):
                return HttpResponse("You're looking at question %s." % question_id)

            def results(request, question_id):
                response = "You're looking at the results of question %s."
                return HttpResponse(response % question_id)

            def vote(request, question_id):
                return HttpResponse("You're voting on question %s." % question_id)


        ğŸ”¶ polls/urls.py
            from django.urls import path

            from . import views

            urlpatterns = [
                # ex: /polls/
                path('', views.index, name='index'),
                # ex: /polls/5/
                path('<int:question_id>/', views.detail, name='detail'),
                # ex: /polls/5/results/
                path('<int:question_id>/results/', views.results, name='results'),
                # ex: /polls/5/vote/
                path('<int:question_id>/vote/', views.vote, name='vote'),
            ]

        When somebody requests a page from your website â€“ say, â€œ/polls/98/â€, Django will load the mysite.urls Python module because itâ€™s pointed to by the ROOT_URLCONF setting. It finds the variable named urlpatterns and traverses the patterns in order. After finding the match at 'polls/', it strips off the matching text ("polls/") and sends the remaining text â€“ "98/" â€“ to the â€˜polls.urlsâ€™ URLconf for further processing. There it matches '<int:question_id>/', resulting in a call to the detail() view like so:
                
                detail(request=<HttpRequest object>, question_id=98)
        
        The question_id=34 part comes from <int:question_id>. Using angle brackets â€œcapturesâ€ part of the URL and sends it as a keyword argument to the view function. The :question_id> part of the string defines the name that will be used to identify the matched pattern, and the <int: part is a converter that determines what patterns should match this part of the URL path.
        
        NO NEED FOR:
                path('polls/latest.html', views.index),

    ğŸ”¸Write views that actually do something
        
        ğŸ”¶ polls/views.py
            from django.http import HttpResponse

            from .models import Question


            def index(request):
                latest_question_list = Question.objects.order_by('-pub_date')[:5]
                output = ', '.join([q.question_text for q in latest_question_list])
                return HttpResponse(output)

            # Leave the rest of the views (detail, results, vote) unchanged

        
        SAMPLE OUTPUT:
            Where are you?, What's up?

        Thereâ€™s a problem here, though: the pageâ€™s design is hard-coded in the view. If you want to change the way the page looks, youâ€™ll have to edit this Python code. So letâ€™s use Djangoâ€™s template system to separate the design from Python by creating a template that the view can use.

        ğŸ”¶
        1. Create a directory called 'templates' in polls directory. 
            Django will look for templates in there.
            Your projectâ€™s TEMPLATES setting describes how Django will load and render templates. The default settings file configures a DjangoTemplates backend whose APP_DIRS option is set to True. By convention DjangoTemplates looks for a â€œtemplatesâ€ subdirectory in each of the INSTALLED_APPS.
        2. Within templates directory, create another directory called 'polls'
        3. Within templates/polls, create a file called 'index.html'

            ğŸ”¶ polls/templates/polls/index.html
                {% if latest_question_list %}
                    <ul>
                    {% for question in latest_question_list %}
                        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
                    {% endfor %}
                    </ul>
                {% else %}
                    <p>No polls are available.</p>
                {% endif %}
        
        To use the template:
            UPDATE:
                ğŸ”¶ polls/views.py
                    from django.http import HttpResponse
                    from django.template import loader

                    from .models import Question


                    def index(request):
                        latest_question_list = Question.objects.order_by('-pub_date')[:5]
                        template = loader.get_template('polls/index.html')
                        context = {
                            'latest_question_list': latest_question_list,
                        }
                        return HttpResponse(template.render(context, request))

            context
                - a dictionary mapping template variable names to Python objects.
        
        A shortcut: render()
            UPDATE:
                ğŸ”¶ polls/views.py
                    from django.shortcuts import render

                    from .models import Question


                    def index(request):
                        latest_question_list = Question.objects.order_by('-pub_date')[:5]
                        context = {'latest_question_list': latest_question_list}
                        return render(request, 'polls/index.html', context)
            
            Note that once weâ€™ve done this in all these views, we no longer need to import loader and HttpResponse (youâ€™ll want to keep HttpResponse if you still have the stub methods for detail, results, and vote).
            
            render() function
                - takes the request object as its first argument, a template name as its second argument and a dictionary as its optional third argument. It returns an HttpResponse object of the given template rendered with the given context.

    ğŸ”¸Raising a 404 error

        ğŸ”¶ polls/views.py
            from django.http import Http404
            from django.shortcuts import render

            from .models import Question
            # ...
            def detail(request, question_id):
                try:
                    question = Question.objects.get(pk=question_id)
                except Question.DoesNotExist:
                    raise Http404("Question does not exist")
                return render(request, 'polls/detail.html', {'question': question})

        ğŸ”¶ polls/templates/polls/detail.html
            {{ question }}
        
        A shortcut: get_object_or_404()
            - shortcut for get() and raise Http404 if the object doesnâ€™t exist
            
            UPDATE:
                ğŸ”¶ polls/views.py
                    from django.shortcuts import get_object_or_404, render

                    from .models import Question
                    # ...
                    def detail(request, question_id):
                        question = get_object_or_404(Question, pk=question_id)
                        return render(request, 'polls/detail.html', {'question': question})

            - takes a Django model as its first argument and an arbitrary number of keyword arguments, which it passes to the get() function of the modelâ€™s manager. It raises Http404 if the object doesnâ€™t exist.

        Why do we use a helper function get_object_or_404() instead of automatically catching the ObjectDoesNotExist exceptions at a higher level, or having the model API raise Http404 instead of ObjectDoesNotExist?

        Because that would couple the model layer to the view layer. One of the foremost design goals of Django is to maintain loose coupling. Some controlled coupling is introduced in the django.shortcuts module.

        get_list_or_404() function
            - which works just as get_object_or_404() â€“ except using filter() instead of get().
            - raises Http404 if the list is empty.

    ğŸ”¸Use the template system

        UPDATE:
            ğŸ”¶ polls/templates/polls/detail.html
                <h1>{{ question.question_text }}</h1>
                <ul>
                {% for choice in question.choice_set.all %}
                    <li>{{ choice.choice_text }}</li>
                {% endfor %}
                </ul>

    ğŸ”¸Removing hardcoded URLs in templates
        
        UPDATE:
            ğŸ”¶ polls/templates/polls/index.html
                ...
                <li>
                    <a href="{% url 'detail' question.id %}">{{ question.question_text }}</a>
                </li>
                ...

            The way this works is by looking up the URL definition as specified in the polls.urls module. You can see exactly where the URL name of â€˜detailâ€™ is defined below:

                ...
                # the 'name' value as called by the {% url %} template tag
                path('<int:question_id>/', views.detail, name='detail'),
                ...

            If you want to change the URL of the polls detail view to something else, perhaps to something like polls/specifics/12/ instead of doing it in the template (or templates) you would change it in polls/urls.py:

                ...
                # added the word 'specifics'
                path('specifics/<int:question_id>/', views.detail, name='detail'),
                ...

    ğŸ”¸Namespacing URL names
        - add namespaces to your URLconf to differentiate the URL names between number of apps;
        - so that Django knows which app view to create for a url when using the {% url %} template tag

        ğŸ”¶ polls/urls.py
            from django.urls import path

            from . import views

            app_name = 'polls'
            urlpatterns = [
                path('', views.index, name='index'),
                path('<int:question_id>/', views.detail, name='detail'),
                path('<int:question_id>/results/', views.results, name='results'),
                path('<int:question_id>/vote/', views.vote, name='vote'),
            ]
            
        UPDATE:
            FROM:
                polls/templates/polls/index.html
                    ...
                    <li>
                        <a href="{% url 'detail' question.id %}">{{ question.question_text }}</a>
                    </li>
                    ...

            ğŸ”¶ polls/templates/polls/index.html
                ...
                <li>
                    <a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a>
                </li>
                ...


ğŸ”µ Writing your first Django app, part 4

    ğŸ”¸Write a minimal form
        
        UPDATE:
            ğŸ”¶ polls/templates/polls/detail.htmlÂ¶
                <h1>{{ question.question_text }}</h1>

                {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

                <form action="{% url 'polls:vote' question.id %}" method="post">
                {% csrf_token %}
                {% for choice in question.choice_set.all %}
                    <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
                    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
                {% endfor %}
                <input type="submit" value="Vote">
                </form>

            NOTES:
                ğŸ”¸ The above template displays a radio button for each question choice. The value of each radio button is the associated question choiceâ€™s ID. The name of each radio button is "choice". That means, when somebody selects one of the radio buttons and submits the form, itâ€™ll send the POST data choice=# where # is the ID of the selected choice. This is the basic concept of HTML forms.
                ğŸ”¸ We set the formâ€™s action to {% url 'polls:vote' question.id %}, and we set method="post". Using method="post" (as opposed to method="get") is very important, because the act of submitting this form will alter data server-side. Whenever you create a form that alters data server-side, use method="post". This tip isnâ€™t specific to Django; itâ€™s good Web development practice in general.
                ğŸ”¸forloop.counter indicates how many times the for tag has gone through its loop
                ğŸ”¸ Since weâ€™re creating a POST form (which can have the effect of modifying data), we need to worry about Cross Site Request Forgeries. Thankfully, you donâ€™t have to worry too hard, because Django comes with a helpful system for protecting against it. In short, all POST forms that are targeted at internal URLs should use the {% csrf_token %} template tag.
                
                    csrf_token
                        - used for CSRF (type of attack) protection
                        
                        CSRF
                            - middleware and template tag provides easy-to-use protection against Cross Site Request Forgeries.
                            - occurs when a malicious website contains a link, a form button or some JavaScript that is intended to perform some action on your website, using the credentials of a logged-in user who visits the malicious site in their browser. A related type of attack, â€˜login CSRFâ€™, where an attacking site tricks a userâ€™s browser into logging into a site with someone elseâ€™s credentials, is also covered.
        
        
        UPDATE:
            ğŸ”¶ polls/views.py
                from django.http import HttpResponse, HttpResponseRedirect
                from django.shortcuts import get_object_or_404, render
                from django.urls import reverse

                from .models import Choice, Question
                # ...
                def vote(request, question_id):
                    question = get_object_or_404(Question, pk=question_id)
                    try:
                        selected_choice = question.choice_set.get(pk=request.POST['choice'])
                    except (KeyError, Choice.DoesNotExist):
                        # Redisplay the question voting form.
                        return render(request, 'polls/detail.html', {
                            'question': question,
                            'error_message': "You didn't select a choice.",
                        })
                    else:
                        selected_choice.votes += 1
                        selected_choice.save()
                        # Always return an HttpResponseRedirect after successfully dealing
                        # with POST data. This prevents data from being posted twice if a
                        # user hits the Back button.
                        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
        
            NOTES:
                ğŸ”¸request.POST is a dictionary-like object that lets you access submitted data by key name. In this case, request.POST['choice'] returns the ID of the selected choice, as a string. request.POST values are always strings.

                Note that Django also provides request.GET for accessing GET data in the same way â€“ but weâ€™re explicitly using request.POST in our code, to ensure that data is only altered via a POST call.

                ğŸ”¸request.POST['choice'] will raise KeyError if choice wasnâ€™t provided in POST data. The above code checks for KeyError and redisplays the question form with an error message if choice isnâ€™t given.

                ğŸ”¸After incrementing the choice count, the code returns an HttpResponseRedirect rather than a normal HttpResponse. HttpResponseRedirect takes a single argument: the URL to which the user will be redirected (see the following point for how we construct the URL in this case).

                As the Python comment above points out, you should always return an HttpResponseRedirect after successfully dealing with POST data. This tip isnâ€™t specific to Django; itâ€™s good Web development practice in general.

                ğŸ”¸We are using the reverse() function in the HttpResponseRedirect constructor in this example. This function helps avoid having to hardcode a URL in the view function. It is given the name of the view that we want to pass control to and the variable portion of the URL pattern that points to that view. In this case, using the URLconf we set up in Tutorial 3, this reverse() call will return a string like
                        '/polls/3/results/'
                    
        
        UPDATE:
            ğŸ”¶ polls/views.py
                from django.shortcuts import get_object_or_404, render


                def results(request, question_id):
                    question = get_object_or_404(Question, pk=question_id)
                    return render(request, 'polls/results.html', {'question': question})
            
        
        ğŸ”¶ polls/templates/polls/results.html
            <h1>{{ question.question_text }}</h1>

            <ul>
            {% for choice in question.choice_set.all %}
                <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
            {% endfor %}
            </ul>

            <a href="{% url 'polls:detail' question.id %}">Vote again?</a>
            
    ğŸ”¸Use generic views: Less code is better
        
        Generic views abstract common patterns to the point where you donâ€™t even need to write Python code to write an app.

        convert our poll app to use the generic views system:
            1. Convert the URLconf.
            2. Delete some of the old, unneeded views.
            3. Introduce new views based on Djangoâ€™s generic views.
        
        ğŸ”¸Amend URLconf
            - open the polls/urls.py URLconf and change it like so:
            - <question_id> to <pk>

            UPDATE:
                ğŸ”¶ polls/urls.py
                    from django.urls import path

                    from . import views

                    app_name = 'polls'
                    urlpatterns = [
                        path('', views.IndexView.as_view(), name='index'),
                        path('<int:pk>/', views.DetailView.as_view(), name='detail'),
                        path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
                        path('<int:question_id>/vote/', views.vote, name='vote'),
                    ]

        ğŸ”¸Amend views
            - remove our old index, detail, and results views and use Djangoâ€™s generic views instead. To do so, open the polls/views.py file and change it like so:
           
            UPDATE:
                ğŸ”¶ polls/views.py
                    from django.http import HttpResponseRedirect
                    from django.shortcuts import get_object_or_404, render
                    from django.urls import reverse
                    from django.views import generic

                    from .models import Choice, Question


                    class IndexView(generic.ListView):
                        template_name = 'polls/index.html'
                        context_object_name = 'latest_question_list'

                        def get_queryset(self):
                            """Return the last five published questions."""
                            return Question.objects.order_by('-pub_date')[:5]


                    class DetailView(generic.DetailView):
                        model = Question
                        template_name = 'polls/detail.html'


                    class ResultsView(generic.DetailView):
                        model = Question
                        template_name = 'polls/results.html'


                    def vote(request, question_id):
                        ... # same as above, no changes needed.

            Used 2 generic views:
                ListView    - display a list of objects
                    - uses a default template called <app name>/<model name>_list.html; we use template_name to tell ListView to use our existing "polls/index.html" template.
                    - the automatically generated context variable is question_list. To override this we provide the context_object_name attribute, specifying that we want to use latest_question_list instead. As an alternative approach, you could change your templates to match the new default context variables â€“ but itâ€™s a lot easier to tell Django to use the variable you want.

                DetailView  - display a detail page for a particular type of object
                    
                    - uses a template called <app name>/<model name>_detail.html. In our case, it would use the template "polls/question_detail.html".

                        template_name attribute
                            - used to tell Django to use a specific template name instead of the autogenerated default template name. We also specify the template_name for the results list view â€“ this ensures that the results view and the detail view have a different appearance when rendered, even though theyâ€™re both a DetailView behind the scenes.
                    - the question variable is provided automatically â€“ since weâ€™re using a Django model (Question), Django is able to determine an appropriate name for the context variable.


                ğŸ”¸Each generic view needs to know what model it will be acting upon. This is provided using the model attribute.
                ğŸ”¸The DetailView generic view expects the primary key value captured from the URL to be called "pk", so weâ€™ve changed question_id to pk for the generic views.
        
        
ğŸ”µ Writing your first Django app, part 5

    ğŸ”¸Introducing automated testing
        What are automated tests?
            
            Tests 
                - routines that check the operation of your code.
        
        Why you need to create tests
            Tests will save you time
            Tests donâ€™t just identify problems, they prevent them
            Tests make your code more attractive
            Tests help teams work together

    ğŸ”¸Basic testing strategies
        Some programmers follow a discipline called â€œtest-driven developmentâ€;
            - they actually write their tests before they write their code.
            - This might seem counter-intuitive, but in fact itâ€™s similar to what most people will often do anyway: they describe a problem, then create some code to solve it. 
            - formalizes the problem in a Python test case.

    ğŸ”¸Writing our first test
        
        â—½ We identify a bug

            ğŸ”¶ python manage.py shell
                >>> import datetime
                >>> from django.utils import timezone
                >>> from polls.models import Question
                >>> # create a Question instance with pub_date 30 days in the future
                >>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
                >>> # was it published recently?
                >>> future_question.was_published_recently()
                True

        â—½ Create a test to expose the bug

            ğŸ”¶ polls/tests.py
                import datetime

                from django.test import TestCase
                from django.utils import timezone

                from .models import Question


                class QuestionModelTests(TestCase):

                    def test_was_published_recently_with_future_question(self):
                        """
                        was_published_recently() returns False for questions whose pub_date
                        is in the future.
                        """
                        time = timezone.now() + datetime.timedelta(days=30)
                        future_question = Question(pub_date=time)
                        self.assertIs(future_question.was_published_recently(), False)

            Here we have created a django.test.TestCase subclass with a method that creates a Question instance with a pub_date in the future. We then check the output of was_published_recently() - which ought to be False.

        â—½ Running tests

            ğŸ”¶ python manage.py test polls

                SAMPLE OUTPUT:
                    Creating test database for alias 'default'...
                    System check identified no issues (0 silenced).
                    F
                    ======================================================================
                    FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
                    ----------------------------------------------------------------------
                    Traceback (most recent call last):
                    File "/home/webdev/more_python/django/mysite/polls/tests.py", line 17, in test_was_published_recently_with_future_question
                        self.assertIs(future_question.was_published_recently(), False)
                    AssertionError: True is not False

                    ----------------------------------------------------------------------
                    Ran 1 test in 0.001s

                    FAILED (failures=1)
                    Destroying test database for alias 'default'...

            What happened is this:

                ğŸ”¸manage.py test polls looked for tests in the polls application
                ğŸ”¸it found a subclass of the django.test.TestCase class
                ğŸ”¸it created a special database for the purpose of testing
                ğŸ”¸it looked for test methods - ones whose names begin with test
                ğŸ”¸in test_was_published_recently_with_future_question it created a Question instance whose pub_date field is 30 days in the future
                ğŸ”¸â€¦ and using the assertIs() method, it discovered that its was_published_recently() returns True, though we wanted it to return False
            
            The test informs us which test failed and even the line on which the failure occurred.
        
        â—½ Fixing the bug
            We already know what the problem is: Question.was_published_recently() should return False if its pub_date is in the future. Amend the method in models.py, so that it will only return True if the date is also in the past:

            ğŸ”¶ polls/models.py
                def was_published_recently(self):
                    now = timezone.now()
                    return now - datetime.timedelta(days=1) <= self.pub_date <= now
            
            ğŸ”¶ python manage.py test polls

                SAMPLE OUTPUT:
                    Creating test database for alias 'default'...
                    System check identified no issues (0 silenced).
                    .
                    ----------------------------------------------------------------------
                    Ran 1 test in 0.001s

                    OK
                    Destroying test database for alias 'default'...
        
        â—½ More comprehensive tests
            
            ğŸ”¶ polls/tests.py
                def test_was_published_recently_with_old_question(self):
                    """
                    was_published_recently() returns False for questions whose pub_date
                    is older than 1 day.
                    """
                    time = timezone.now() - datetime.timedelta(days=1, seconds=1)
                    old_question = Question(pub_date=time)
                    self.assertIs(old_question.was_published_recently(), False)

                def test_was_published_recently_with_recent_question(self):
                    """
                    was_published_recently() returns True for questions whose pub_date
                    is within the last day.
                    """
                    time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
                    recent_question = Question(pub_date=time)
                    self.assertIs(recent_question.was_published_recently(), True)

    ğŸ”¸Test a view
        â—½ A test for a view
            In our first test, we focused closely on the internal behavior of the code. For this test, we want to check its behavior as it would be experienced by a user through a web browser.

            Before we try to fix anything, letâ€™s have a look at the tools at our disposal.

        â—½ The Django test client

            ğŸ”¶ python manage.py shell
                >>> from django.test.utils import setup_test_environment
                >>> setup_test_environment()
                >>> from django.test import Client
                >>> # create an instance of the client for our use
                >>> client = Client()
                >>> 
                >>> # get a response from '/'
                >>> response = client.get('/')
                Not Found: /
                >>> # we should expect a 404 from that address; if you instead see an
                >>> # "Invalid HTTP_HOST header" error and a 400 response, you probably
                >>> # omitted the setup_test_environment() call described earlier.
                >>> response.status_code
                404
                >>> # on the other hand we should expect to find something at '/polls/'
                >>> # we'll use 'reverse()' rather than a hardcoded URL
                >>> from django.urls import reverse
                >>> response = client.get(reverse('polls:index'))
                >>> response.status_code
                200
                >>> 
                >>> response.content
                b'\n<ul>\n  \n  <!-- <li><a href="/polls/2/">Where are you?</a></li> -->\n  <li>\n    <a href="/polls/2/"\n      >Where are you?</a\n    >\n  </li>\n  \n  <!-- <li><a href="/polls/1/">What&#x27;s up? </a></li> -->\n  <li>\n    <a href="/polls/1/"\n      >What&#x27;s up? </a\n    >\n  </li>\n  \n</ul>\n\n'
                >>> response.context['latest_question_list']
                <QuerySet [<Question: Where are you?>, <Question: What's up? >]>
                >>> 

        â—½ Improving our view
            The list of polls shows polls that arenâ€™t published yet (i.e. those that have a pub_date in the future). Letâ€™s fix that.

            ğŸ”¶ polls/views.py
                from django.utils import timezone
                ...

                def get_queryset(self):
                    """
                    Return the last five published questions
                    (not including those set to be published
                    in the future).
                    """
                    # return Question.objects.order_by("-pub_date")[:5]
                    return Question.objects.filter(pub_date__lte=timezone.now()).order_by(
                        "-pub_date"
                    )[:5]
                ...

            Question.objects.filter(pub_date__lte=timezone.now()) returns a queryset containing Questions whose pub_date is less than or equal to - that is, earlier than or equal to - timezone.now.

        â—½ Testing our new view
                
            ADD:
                ğŸ”¶ polls/tests.py
                    from django.urls import reverse
                    ...
                    ...

                    
                    # a shortcut function to create questions as well as a new test class:
                    def create_question(question_text, days):
                        """
                        Create a question with the given `question_text` and published the
                        given number of `days` offset to now (negative for questions published
                        in the past, positive for questions that have yet to be published).
                        """
                        time = timezone.now() + datetime.timedelta(days=days)
                        return Question.objects.create(question_text=question_text, pub_date=time)


                    class QuestionIndexViewTests(TestCase):
                        def test_no_questions(self):
                            """
                            If no questions exist, an appropriate message is displayed.
                            """
                            response = self.client.get(reverse("polls:index"))
                            self.assertEqual(response.status_code, 200)
                            self.assertContains(response, "No polls are available.")
                            self.assertQuerysetEqual(response.context["latest_question_list"], [])

                        def test_past_question(self):
                            """
                            Questions with a pub_date in the past are displayed on the
                            index page.
                            """
                            create_question(question_text="Past question.", days=-30)
                            response = self.client.get(reverse("polls:index"))
                            self.assertQuerysetEqual(
                                response.context["latest_question_list"], ["<Question: Past question.>"]
                            )

                        def test_future_question(self):
                            """
                            Questions with a pub_date in the future aren't displayed on
                            the index page.
                            """
                            create_question(question_text="Future question.", days=30)
                            response = self.client.get(reverse("polls:index"))
                            self.assertContains(response, "No polls are available.")
                            self.assertQuerysetEqual(response.context["latest_question_list"], [])

                        def test_future_question_and_past_question(self):
                            """
                            Even if both past and future questions exist, only past questions
                            are displayed.
                            """
                            create_question(question_text="Past question.", days=-30)
                            create_question(question_text="Future question.", days=30)
                            response = self.client.get(reverse("polls:index"))
                            self.assertQuerysetEqual(
                                response.context["latest_question_list"], ["<Question: Past question.>"]
                            )

                        def test_two_past_questions(self):
                            """
                            The questions index page may display multiple questions.
                            """
                            create_question(question_text="Past question 1.", days=-30)
                            create_question(question_text="Past question 2.", days=-5)
                            response = self.client.get(reverse("polls:index"))
                            self.assertQuerysetEqual(
                                response.context["latest_question_list"],
                                ["<Question: Past question 2.>", "<Question: Past question 1.>"],
                            )

            NOTES:
                ğŸ”¸First is a question shortcut function, 'create_question', to take some repetition out of the process of creating questions.

                ğŸ”¸test_no_questions doesnâ€™t create any questions, but checks the message: â€œNo polls are available.â€ and verifies the latest_question_list is empty. Note that the django.test.TestCase class provides some additional assertion methods. In these examples, we use assertContains() and assertQuerysetEqual().

                ğŸ”¸In test_past_question, we create a question and verify that it appears in the list.

                ğŸ”¸In test_future_question, we create a question with a pub_date in the future. The database is reset for each test method, so the first question is no longer there, and so again the index shouldnâ€™t have any questions in it.

                And so on. In effect, we are using the tests to tell a story of admin input and user experience on the site, and checking that at every state and for every new change in the state of the system, the expected results are published.

        â—½ Testing the DetailView
            
            ADD:
                ğŸ”¶ polls/views.py
                class DetailView(generic.DetailView):
                    ...
                    
                    # To prevent users from viewing future questions through URL
                    def get_queryset(self):
                        """
                        Excludes any questions that aren't published yet.
                        """
                        return Question.objects.filter(pub_date__lte=timezone.now())
            
            ADD:
                ğŸ”¶ polls/tests.py
                    ...
                    ...

                    # to check that a Question whose pub_date is in the past can
                    # be displayed, and that one with a pub_date in the future is not:
                    class QuestionDetailViewTests(TestCase):
                        def test_future_question(self):
                            """
                            The detail view of a question with a pub_date in the future
                            returns a 404 not found.
                            """
                            future_question = create_question(question_text='Future question.', days=5)
                            url = reverse('polls:detail', args=(future_question.id,))
                            response = self.client.get(url)
                            self.assertEqual(response.status_code, 404)

                        def test_past_question(self):
                            """
                            The detail view of a question with a pub_date in the past
                            displays the question's text.
                            """
                            past_question = create_question(question_text='Past Question.', days=-5)
                            url = reverse('polls:detail', args=(past_question.id,))
                            response = self.client.get(url)
                            self.assertContains(response, past_question.question_text)

        
        â—½ Ideas for more tests
            We ought to add a similar get_queryset method to ResultsView and create a new test class for that view. Itâ€™ll be very similar to what we have just created; in fact there will be a lot of repetition.

            We could also improve our application in other ways, adding tests along the way. For example, itâ€™s silly that Questions can be published on the site that have no Choices. So, our views could check for this, and exclude such Questions. Our tests would create a Question without Choices and then test that itâ€™s not published, as well as create a similar Question with Choices, and test that it is published.

            Perhaps logged-in admin users should be allowed to see unpublished Questions, but not ordinary visitors. Again: whatever needs to be added to the software to accomplish this should be accompanied by a test, whether you write the test first and then make the code pass the test, or work out the logic in your code first and then write a test to prove it.

            At a certain point you are bound to look at your tests and wonder whether your code is suffering from test bloat, which brings us to:

    ğŸ”¸When testing, more is better
        It might seem that our tests are growing out of control. At this rate there will soon be more code in our tests than in our application, and the repetition is unaesthetic, compared to the elegant conciseness of the rest of our code.

        ğŸ”¸It doesnâ€™t matter. Let them grow. For the most part, you can write a test once and then forget about it. It will continue performing its useful function as you continue to develop your program.

        Sometimes tests will need to be updated. Suppose that we amend our views so that only Questions with Choices are published. In that case, many of our existing tests will fail - telling us exactly which tests need to be amended to bring them up to date, so to that extent tests help look after themselves.

        At worst, as you continue developing, you might find that you have some tests that are now redundant. Even thatâ€™s not a problem; ğŸ”¸in testing redundancy is a good thing.

        As long as your tests are sensibly arranged, they wonâ€™t become unmanageable. Good rules-of-thumb include having:

            â—½ a separate TestClass for each model or view
            â—½ a separate test method for each set of conditions you want to test
            â—½ test method names that describe their function

    ğŸ”¸Further testing


ğŸ”µ Writing your first Django app, part 6
    
    static files
        - web applications generally need to serve additional files â€” such as images, JavaScript, or CSS â€” necessary to render the complete web page

    ğŸ”¸Customize your appâ€™s look and feel
        
        static (directory)
            - Django will look for static files there

        Djangoâ€™s STATICFILES_FINDERS setting
            - contains a list of finders that know how to discover static files from various sources. One of the defaults is AppDirectoriesFinder which looks for a â€œstaticâ€ subdirectory in each of the INSTALLED_APPS, like the one in polls we just created. The admin site uses the same directory structure for its static files.
        
        {% static %} template tag
            - generates the absolute URL of static files.
        
        STATIC_URL
            - used by the static template tag to generate its URLs   
            - Default: None
            - URL to use when referring to static files located in STATIC_ROOT.
                ex:
                    "/static/" or "http://static.example.com/"
            - If not None, this will be used as the base path for asset definitions (the Media class) and the staticfiles app.
            - It must end in a slash if set to a non-empty value.

        STATIC_ROOT
            - Default: None
            - The absolute path to the directory where collectstatic will collect static files for deployment.
                ex: 
                    "/var/www/example.com/static/"
            - If the staticfiles contrib app is enabled (as in the default project template), the collectstatic management command will collect static files into this directory. See the how-to on managing static files for more details about usage.


            collectstatic
                - will collect static files for deployment.
                - Collects the static files into STATIC_ROOT.

                ex:
                    from django.contrib.staticfiles import storage

                    class MyStaticFilesStorage(storage.StaticFilesStorage):
                        def __init__(self, *args, **kwargs):
                            kwargs['file_permissions_mode'] = 0o640
                            kwargs['directory_permissions_mode'] = 0o760
                            super().__init__(*args, **kwargs)


            django-admin collectstatic
                - Command used to collects the static files into STATIC_ROOT.

        STATICFILES_DIRS
            - Default: [] (Empty list)
            - This setting defines the additional locations the staticfiles app will traverse if the FileSystemFinder finder is enabled, e.g. if you use the collectstatic or findstatic management command or use the static file serving view.
            - This should be set to a list of strings that contain full paths to your additional files directory(ies)       e.g.:
                    STATICFILES_DIRS = [
                        "/home/special.polls.com/polls/static",
                        "/home/polls.com/polls/static",
                        "/opt/webfiles/common",
                    ]

        STATICFILES_STORAGE
            - Default: 'django.contrib.staticfiles.storage.StaticFilesStorage'
            - The file storage engine to use when collecting static files with the collectstatic management command.
            - A ready-to-use instance of the storage backend defined in this setting can be found at django.contrib.staticfiles.storage.staticfiles_storage.
                ex:
                    (see Serving static files from a cloud service or CDN)

                    STATICFILES_STORAGE = 'myproject.storage.S3Storage'

        STATICFILES_FINDERSÂ¶
            - Default:
                [
                    'django.contrib.staticfiles.finders.FileSystemFinder',
                    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
                ]
            - The list of finder backends that know how to find static files in various locations.
            - The default will find files stored in the STATICFILES_DIRS setting (using django.contrib.staticfiles.finders.FileSystemFinder) and in a static subdirectory of each app (using django.contrib.staticfiles.finders.AppDirectoriesFinder). If multiple files with the same name are present, the first file that is found will be used.
            - One finder is disabled by default: django.contrib.staticfiles.finders.DefaultStorageFinder. If added to your STATICFILES_FINDERS setting, it will look for static files in the default file storage as defined by the DEFAULT_FILE_STORAGE setting.






        ğŸ”¶        
        1. Create a directory called 'static' in polls directory. 
        2. Within static directory, create another directory called 'polls'
        3. Within static/polls create a css file named 'style.css'
            
            ğŸ”¶ polls/static/polls/style.css
                li a {
                    color: green;
                }

        UPDATE:
            Add at the top:
            ğŸ”¶ polls/templates/polls/index.html
                {% load static %}

                <link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}">
                ...
                ...

        RESTART server:
            ğŸ”¶ python manage.py runserver
    
    

            
    ğŸ”¸Adding a background-image
        
        ğŸ”¶ 
        1. Create an 'images' subdirectory inside polls/static/polls/
        2. Inside this directory, put an image called 'background.gif'
            polls/static/polls/images/background.gif

        UPDATE:
            ğŸ”¶ polls/static/polls/style.css
                body {
                    background: white url("images/background.gif") no-repeat;
                }

       
ğŸ”µ Writing your first Django app, part 7

    ğŸ”¸Customize the admin form
        By registering the Question model with admin.site.register(Question), Django was able to construct a default form representation. Often, youâ€™ll want to customize how the admin form looks and works. Youâ€™ll do this by telling Django the options you want when you register the object.

        Letâ€™s see how this works by reordering the fields on the edit form. Replace the admin.site.register(Question) line with:


            ğŸ”¶ polls/admin.py
                from django.contrib import admin

                from .models import Question


                class QuestionAdmin(admin.ModelAdmin):
                    fields = ['pub_date', 'question_text']

                admin.site.register(Question, QuestionAdmin)

        Youâ€™ll follow this pattern â€“ create a model admin class, then pass it as the second argument to admin.site.register() â€“ any time you need to change the admin options for a model.

        This particular change above makes the â€œPublication dateâ€ come before the â€œQuestionâ€ field:

            SAMPLE OUTPUT:
                files/admin1.png


        This isnâ€™t impressive with only two fields, but for admin forms with dozens of fields, choosing an intuitive order is an important usability detail.

        And speaking of forms with dozens of fields, you might want to split the form up into fieldsets:

            UPDATE:
                ğŸ”¶ polls/admin.py
                    from django.contrib import admin

                    from .models import Question


                    class QuestionAdmin(admin.ModelAdmin):
                        fieldsets = [
                            (None,               {'fields': ['question_text']}),
                            ('Date information', {'fields': ['pub_date']}),
                        ]

                    admin.site.register(Question, QuestionAdmin)
            
            SAMPLE OUTPUT:
                files/admin2.png


    ğŸ”¸Adding related objects
        OK, we have our Question admin page, but a Question has multiple Choices, and the admin page doesnâ€™t display choices.

        Yet.

        There are two ways to solve this problem. The first is to register Choice with the admin just as we did with Question:
        
        UPDATE:
            ğŸ”¶ polls/admin.py
                from django.contrib import admin

                from .models import Choice, Question
                # ...
                admin.site.register(Choice)


        Now â€œChoicesâ€ is an available option in the Django admin. The â€œAdd choiceâ€ form looks like this:
            files/admin3.png

        In that form, the â€œQuestionâ€ field is a select box containing every question in the database. Django knows that a ForeignKey should be represented in the admin as a <select> box. In our case, only one question exists at this point.

        Also note the â€œAdd Anotherâ€ link next to â€œQuestion.â€ Every object with a ForeignKey relationship to another gets this for free. When you click â€œAdd Anotherâ€, youâ€™ll get a popup window with the â€œAdd questionâ€ form. If you add a question in that window and click â€œSaveâ€, Django will save the question to the database and dynamically add it as the selected choice on the â€œAdd choiceâ€ form youâ€™re looking at.

        But, really, this is an inefficient way of adding Choice objects to the system. Itâ€™d be better if you could add a bunch of Choices directly when you create the Question object. Letâ€™s make that happen.

        Remove the register() call for the Choice model. Then, edit the Question registration code to read:
            
            ğŸ”¶ polls/admin.py
                from django.contrib import admin

                from .models import Choice, Question


                class ChoiceInline(admin.StackedInline):
                    model = Choice
                    extra = 3


                class QuestionAdmin(admin.ModelAdmin):
                    fieldsets = [
                        (None,               {'fields': ['question_text']}),
                        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
                    ]
                    inlines = [ChoiceInline]

                admin.site.register(Question, QuestionAdmin)

        This tells Django: â€œChoice objects are edited on the Question admin page. By default, provide enough fields for 3 choices.â€

        Load the â€œAdd questionâ€ page to see how that looks:
            files/admin5.png

        It works like this: There are three slots for related Choices â€“ as specified by extra â€“ and each time you come back to the â€œChangeâ€ page for an already-created object, you get another three extra slots.

        At the end of the three current slots you will find an â€œAdd another Choiceâ€ link. If you click on it, a new slot will be added. If you want to remove the added slot, you can click on the X to the top right of the added slot. Note that you canâ€™t remove the original three slots. This image shows an added slot:
            files/admin6.png

   
        Change the view for Choices (in admin side) as a tabular way of displaying inline related objects:
            ğŸ”¶ polls/admin.py
                ...

                class ChoiceInline(admin.TabularInline):
                ...
                ...

    ğŸ”¸Customize the admin change list
        Now that the Question admin page is looking good, letâ€™s make some tweaks to the â€œchange listâ€ page â€“ the one that displays all the questions in the system.

        Hereâ€™s what it looks like at this point:
            files/admin8.png

        By default, Django displays the 'str()' of each object. But sometimes itâ€™d be more helpful if we could display individual fields. To do that, use the 'list_display' admin option, which is a tuple of field names to display, as columns, on the change list page for the object:

        In 'Select question to change', display 3 columns named as 'Question Text', 'Date Published', and 'Was Published Recently':
        
            UPDATE:
                ğŸ”¶ polls/admin.py
                    ...
                    
                    class QuestionAdmin(admin.ModelAdmin):
                        ...
                        list_display = ('question_text', 'pub_date', 'was_published_recently')

            SAMPLE OUTPUT:
                files/admin9.png

        You can click on the column headers to sort by those values â€“ except in the case of the was_published_recently header, because sorting by the output of an arbitrary method is not supported. Also note that the column header for was_published_recently is, by default, the name of the method (with underscores replaced with spaces), and that each line contains the string representation of the output.

        You can improve that by giving that method (in polls/models.py) a few attributes, as follows:
        
            UPDATE:
                ğŸ”¶ polls/models.py
                    ...
                    
                    class Question(models.Model):
                        # ...
                        def was_published_recently(self):
                            now = timezone.now()
                            return now - datetime.timedelta(days=1) <= self.pub_date <= now
                        was_published_recently.admin_order_field = 'pub_date'
                        was_published_recently.boolean = True
                        was_published_recently.short_description = 'Published recently?'

        Edit your polls/admin.py file again and add an improvement to the Question change list page: filters using the list_filter. Add the following line to QuestionAdmin:
        
            UPDATE:
                ğŸ”¶ polls/admin.py
                    ...

                    class QuestionAdmin(admin.ModelAdmin):
                        ...
                        list_filter = ['pub_date']
                    
                    ...


        That adds a â€œFilterâ€ sidebar that lets people filter the change list by the pub_date field:
            SAMPLE OUTPUT:
                files/admin10.png


        The type of filter displayed depends on the type of field youâ€™re filtering on. Because pub_date is a DateTimeField, Django knows to give appropriate filter options: 
            â€œAny dateâ€,
            â€œTodayâ€,
            â€œPast 7 daysâ€,
            â€œThis monthâ€,
            â€œThis yearâ€.


        Add some search capability:
        
            UPDATE:
                ğŸ”¶ polls/admin.py
                    ...

                    class QuestionAdmin(admin.ModelAdmin):
                        ...
                        search_fields = ['question_text']

                    ...

            SAMPLE OUTPUT:
                files/admin11.png
        
        That adds a search box at the top of the change list. When somebody enters search terms, Django will search the question_text field. You can use as many fields as youâ€™d like â€“ although because it uses a LIKE query behind the scenes, limiting the number of search fields to a reasonable number will make it easier for your database to do the search.

        Nowâ€™s also a good time to note that change lists give you free pagination. The default is to display 100 items per page. Change list pagination, search boxes, filters, date-hierarchies, and column-header-ordering all work together like you think they should.
    

        ModelAdmin
        
            ğŸ”¹fieldsets
                - set to control the layout of admin â€œaddâ€ and â€œchangeâ€ pages.
                - a list of two-tuples, in which each two-tuple represents a <fieldset> on the admin form page. (A <fieldset> is a â€œsectionâ€ of the form.)

                ğŸ”¹fields
                    - A tuple of field names to display in this fieldset. This key is required.          
                    - fields can contain values defined in readonly_fields to be displayed as read-only.
                    - If you add the name of a callable to fields, the same rule applies as with the fields option: the callable must be listed in readonly_fields.
                    
                    ex:
                        {
                            'fields': ('first_name', 'last_name', 'address', 'city', 'state'),
                        }

                    ex: 
                        As with the fields option, to display multiple fields on the same line, wrap those fields in their own tuple. In this example, the first_name and last_name fields will display on the same line:

                        {
                        'fields': (('first_name', 'last_name'), 'address', 'city', 'state'),
                        }
                ğŸ”¹classes
                    A list or tuple containing extra CSS classes to apply to the fieldset.

                    ex:
                        {
                        'classes': ('wide', 'extrapretty'),
                        }

                    - Two useful classes defined by the default admin site stylesheet are 
                        'collapse'
                            - Fieldsets with the collapse style will be initially collapsed in the admin and replaced with a small â€œclick to expandâ€ link.
                        'wide'. 
                            - Fieldsets with the wide style will be given extra horizontal space.

                ğŸ”¹description
                    - A string of optional extra text to be displayed at the top of each fieldset, under the heading of the fieldset. This string is not rendered for TabularInline due to its layout.
                    - Note that this value is not HTML-escaped when itâ€™s displayed in the admin interface. This lets you include HTML if you so desire. Alternatively you can use plain text and django.utils.html.escape() to escape any HTML special characters.
            
            ğŸ”¹list_display
                - set to control which fields are displayed on the change list page of the admin.
                - a tuple of field names to display, as columns, on the change list page for the object:


            ğŸ”¹list_filter
                - set to activate filters in the right sidebar of the change list page of the admin
                - should be a list or tuple of elements, where each element should be of one of the following types:
                    
                    ğŸ”º a field name, where the specified field should be either a BooleanField, CharField, DateField, DateTimeField, IntegerField, ForeignKey or ManyToManyField:

                        class PersonAdmin(admin.ModelAdmin):
                            list_filter = ('is_staff', 'company')

                    Field names in list_filter can also span relations using the __ lookup:

                        class PersonAdmin(admin.UserAdmin):
                            list_filter = ('company__name',)

                    ğŸ”ºa class inheriting from django.contrib.admin.SimpleListFilter, which you need to provide the title and parameter_name attributes to and override the lookups and queryset methods, e.g.:

                        from datetime import date

                        from django.contrib import admin
                        from django.utils.translation import gettext_lazy as _

                        class DecadeBornListFilter(admin.SimpleListFilter):
                            # Human-readable title which will be displayed in the
                            # right admin sidebar just above the filter options.
                            title = _('decade born')

                            # Parameter for the filter that will be used in the URL query.
                            parameter_name = 'decade'

                            def lookups(self, request, model_admin):
                                """
                                Returns a list of tuples. The first element in each
                                tuple is the coded value for the option that will
                                appear in the URL query. The second element is the
                                human-readable name for the option that will appear
                                in the right sidebar.
                                """
                                return (
                                    ('80s', _('in the eighties')),
                                    ('90s', _('in the nineties')),
                                )

                            def queryset(self, request, queryset):
                                """
                                Returns the filtered queryset based on the value
                                provided in the query string and retrievable via
                                `self.value()`.
                                """
                                # Compare the requested value (either '80s' or '90s')
                                # to decide how to filter the queryset.
                                if self.value() == '80s':
                                    return queryset.filter(birthday__gte=date(1980, 1, 1),
                                                            birthday__lte=date(1989, 12, 31))
                                if self.value() == '90s':
                                    return queryset.filter(birthday__gte=date(1990, 1, 1),
                                                            birthday__lte=date(1999, 12, 31))

                        class PersonAdmin(admin.ModelAdmin):
                            list_filter = (DecadeBornListFilter,)

                    ğŸ”ºa tuple, where the first element is a field name and the second element is a class inheriting from django.contrib.admin.FieldListFilter, for example:

                        class PersonAdmin(admin.ModelAdmin):
                            list_filter = (
                                ('is_staff', admin.BooleanFieldListFilter),
                            )
                        You can limit the choices of a related model to the objects involved in that relation using RelatedOnlyFieldListFilter:

                        class BookAdmin(admin.ModelAdmin):
                            list_filter = (
                                ('author', admin.RelatedOnlyFieldListFilter),
                            )

            ğŸ”¹search_fields
                - set to enable a search box on the admin change list page. This should be set to a list of field names that will be searched whenever somebody submits a search query in that text box.
                - These fields should be some kind of text field, such as CharField or TextField. You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API â€œfollowâ€ notation:

                    search_fields = ['foreign_key__related_fieldname']

                EX:
                    if you have a blog entry with an author, the following definition would enable searching blog entries by the email address of the author:

                        search_fields = ['user__email']

                - 
                    Prefix	Lookup
                    ^	startswith
                    =	iexact
                    @	search
                    None	icontains

            ğŸ”¹inlines
                - The admin interface has the ability to edit models on the same page as a parent model





    ğŸ”¸Customize the admin look and feel
        Clearly, having â€œDjango administrationâ€ at the top of each admin page is ridiculous. Itâ€™s just placeholder text.

        You can change it, though, using Djangoâ€™s template system. The Django admin is powered by Django itself, and its interfaces use Djangoâ€™s own template system.

        â—½ Customizing your projectâ€™s templates

            Open your settings file (mysite/settings.py, remember) and add a DIRS option in the TEMPLATES setting:

                UPDATE:
                    ğŸ”¶ mysite/settings.py
                        TEMPLATES = [
                            {
                                'BACKEND': 'django.template.backends.django.DjangoTemplates',
                                'DIRS': [os.path.join(BASE_DIR, 'templates')],
                                'APP_DIRS': True,
                                'OPTIONS': {
                                    'context_processors': [
                                        'django.template.context_processors.debug',
                                        'django.template.context_processors.request',
                                        'django.contrib.auth.context_processors.auth',
                                        'django.contrib.messages.context_processors.messages',
                                    ],
                                },
                            },
                        ]
            DIRS 
                -Default: [] (Empty list)
                - a list of filesystem directories to check when loading Django templates; itâ€™s a search path.
                - Directories where the engine should look for template source files, in search order.


            ğŸ”¶ 
            1. Create a directory called 'admin' inside templates, and 
            2. copy the template 'admin/base_site.html' from within the default Django admin template directory in the source code of Django itself (django/contrib/admin/templates) into that directory: (in terminal)
                1. python -c "import django; print(django.__path__)"
                2. then go to the directory given, ex:
                    cd /home/webdev/.pyenv/versions/3.7.4/lib/python3.7/site-packages/django
                3. ls, then
                4. cd contrib/admin/templates/admin
                5. ls, then
                6. nano base_site.html
                7. copy the text to the newly created base_site.html, then edit the file and replace 
                        {{ site_header|default:_('Django administration') }} 
                    (including the curly braces) with your own siteâ€™s name as you see fit. You should end up with a section of code like:
                        
                        {% block branding %}
                        <h1 id="site-name">
                            <a href="{% url 'admin:index' %}">Polls Administration</a>
                        </h1>
                        {% endblock %}

            We use this approach to teach you how to override templates. In an actual project, you would probably use the django.contrib.admin.AdminSite.site_header attribute to more easily make this particular customization.

            This template file contains lots of text like {% block branding %} and {{ title }}. The {% and {{ tags are part of Djangoâ€™s template language. When Django renders admin/base_site.html, this template language will be evaluated to produce the final HTML page, just like we saw in Tutorial 3.

            Note that any of Djangoâ€™s default admin templates can be overridden. To override a template, do the same thing you did with base_site.html â€“ copy it from the default directory into your custom directory, and make changes.



            Where are the Django source files?
                If you have difficulty finding where the Django source files are located on your system, run the following command:
                    python -c "import django; print(django.__path__)"


        â—½ Customizing your applicationâ€™s templates

            Astute readers will ask: But if DIRS was empty by default, how was Django finding the default admin templates? The answer is that, since 'APP_DIRS' is set to True, Django automatically looks for a templates/ subdirectory within each application package, for use as a fallback (donâ€™t forget that django.contrib.admin is an application).

        
    ğŸ”¸Customize the admin index page
        On a similar note, you might want to customize the look and feel of the Django admin index page.

        By default, it displays all the apps in INSTALLED_APPS that have been registered with the admin application, in alphabetical order. You may want to make significant changes to the layout. After all, the index is probably the most important page of the admin, and it should be easy to use.

        The template to customize is admin/index.html. (Do the same as with admin/base_site.html in the previous section â€“ copy it from the default directory to your custom template directory). Edit the file, and youâ€™ll see it uses a template variable called app_list. That variable contains every installed Django app. Instead of using that, you can hard-code links to object-specific admin pages in whatever way you think is best.